// This file was automatically generated by odin.
// Do not edit by hand as changes will be lost.

// versions:
// hash: 29bea7499b0c88ceb583a599908ae0b2
// odin: 0.0.5
// cinterpolate: 1.0.0
// r: 3.4.4
// platform: x86_64-pc-linux-gnu

#include <R.h>
#include <Rmath.h>
#include <Rinternals.h>
#include <R_ext/Rdynload.h>
#include <stdbool.h>

// Collect together all the parameters and transient memory
// required to run the model in a struct.
typedef struct sir_pars {
  int odin_use_dde;
  double initial_S;
  double initial_I;
  double initial_R;
  double b;
  double g;
} sir_pars;
sir_pars* sir_get_pointer(SEXP sir_ptr, int closed_error);

SEXP get_ds_pars();

// Create the pointer; this will establish the struct, allocate
// memory for things that are constant size, and initialize
// constant variables
static void sir_finalize(SEXP sir_ptr);
SEXP sir_create(SEXP odin_use_dde) {
  sir_pars *sir_p = (sir_pars*) Calloc(1, sir_pars);
  sir_p->initial_S = 0.98999999999999999;
  sir_p->initial_I = 0.01;
  sir_p->initial_R = 0;
  sir_p->b = 0.10000000000000001;
  sir_p->g = 0.050000000000000003;
  SEXP sir_ptr = PROTECT(R_MakeExternalPtr(sir_p, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(sir_ptr, sir_finalize);
  sir_p->odin_use_dde = INTEGER(odin_use_dde)[0];
  UNPROTECT(1);
  return sir_ptr;
}

// Arrange to free all memory we have allocated
// This is called by R automatically when the pointer is
// garbage collected (i.e., when all objects holding the pointer
// go out of scope
void sir_finalize(SEXP sir_ptr) {
  sir_pars *sir_p = sir_get_pointer(sir_ptr, 0);
  if (sir_ptr) {
    Free(sir_p);
    R_ClearExternalPtr(sir_ptr);
  }
}

SEXP sir_initialise(SEXP sir_ptr, SEXP t_ptr) {
  sir_pars *sir_p = sir_get_pointer(sir_ptr, 1);
  SEXP state = PROTECT(allocVector(REALSXP, 3));
  REAL(state)[0] = sir_p->initial_S;
  REAL(state)[1] = sir_p->initial_I;
  REAL(state)[2] = sir_p->initial_R;
  UNPROTECT(1);
  return state;
}

SEXP sir_set_initial(SEXP sir_ptr, SEXP t_ptr, SEXP state_ptr) {
  return R_NilValue;
}

void sir_deriv(sir_pars *sir_p, double t, double *state, double *dstatedt, double *output) {
  double S = state[0];
  double I = state[1];
  dstatedt[0] = -sir_p->b * S * I;
  dstatedt[1] = sir_p->b * S * I - sir_p->g * I;
  dstatedt[2] = sir_p->g * I;
}

// deSolve interface
// Global variable set on initmod, as per deSolve design
static sir_pars *sir_p;
void sir_initmod_ds(void(* odeparms) (int *, double *)) {
  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  sir_p = sir_get_pointer(get_deSolve_gparms(), 1);
}
void sir_deriv_ds(int *neq, double *t, double *state,
                  double *dstatedt, double *output, int *np) {
  sir_deriv(sir_p, *t, state, dstatedt, output);
}

// dde interface
void sir_deriv_dde(size_t n_eq, double t, double *state,
                    double *dstatedt, void *sir_p) {
  sir_deriv((sir_pars*)sir_p, t, state, dstatedt, NULL);
}

SEXP sir_deriv_r(SEXP sir_ptr, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  sir_pars *sir_p = sir_get_pointer(sir_ptr, 1);
  double *output = NULL;
  sir_deriv(sir_p, REAL(t)[0], REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}

// Translate all elements in the struct back to R
// This will mostly be useful for debugging.
SEXP sir_contents(SEXP sir_ptr) {
  sir_pars *sir_p = sir_get_pointer(sir_ptr, 1);
  SEXP state = PROTECT(allocVector(VECSXP, 6));
  SET_VECTOR_ELT(state, 0, ScalarInteger(sir_p->odin_use_dde));
  SET_VECTOR_ELT(state, 1, ScalarReal(sir_p->initial_S));
  SET_VECTOR_ELT(state, 2, ScalarReal(sir_p->initial_I));
  SET_VECTOR_ELT(state, 3, ScalarReal(sir_p->initial_R));
  SET_VECTOR_ELT(state, 4, ScalarReal(sir_p->b));
  SET_VECTOR_ELT(state, 5, ScalarReal(sir_p->g));
  SEXP state_names = PROTECT(allocVector(STRSXP, 6));
  SET_STRING_ELT(state_names, 0, mkChar("odin_use_dde"));
  SET_STRING_ELT(state_names, 1, mkChar("initial_S"));
  SET_STRING_ELT(state_names, 2, mkChar("initial_I"));
  SET_STRING_ELT(state_names, 3, mkChar("initial_R"));
  SET_STRING_ELT(state_names, 4, mkChar("b"));
  SET_STRING_ELT(state_names, 5, mkChar("g"));
  setAttrib(state, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state;
}

// Report back to R information on variable ordering
// The reported information includes position and length of each
// variable, from which offset, etc, can be worked out.
SEXP sir_variable_order(SEXP sir_ptr) {
  SEXP state_len = PROTECT(allocVector(VECSXP, 3));
  SEXP state_names = PROTECT(allocVector(STRSXP, 3));
  SET_VECTOR_ELT(state_len, 0, R_NilValue);
  SET_STRING_ELT(state_names, 0, mkChar("S"));
  SET_VECTOR_ELT(state_len, 1, R_NilValue);
  SET_STRING_ELT(state_names, 1, mkChar("I"));
  SET_VECTOR_ELT(state_len, 2, R_NilValue);
  SET_STRING_ELT(state_names, 2, mkChar("R"));
  setAttrib(state_len, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state_len;
}

sir_pars* sir_get_pointer(SEXP sir_ptr, int closed_error) {
  sir_pars *sir_p = NULL;
  if (TYPEOF(sir_ptr) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  sir_p = (sir_pars*) R_ExternalPtrAddr(sir_ptr);
  if (!sir_p && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return sir_p;
}

SEXP get_ds_pars() {
  static DL_FUNC get_deSolve_gparms = NULL;
  if (get_deSolve_gparms == NULL) {
    get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  }
  return get_deSolve_gparms();
}
